# SwiftCxxCrossModuleImports

This is a reproduction for the issues reported by me in the Swift compiler related to Swift <> C++ interop, discovered while building https://github.com/mrousavy/nitro - currently blocking me.

## Explanation

The project has two libraries, `FirstPod` and `SecondPod`.

Each pod uses Swift <> C++ interop extensively, so there are Swift files that use C++ types, and C++ files that use Swift types:
- `FirstCppTypesExposedToSwift.hpp`: A C++ header that defines some types that I will use in Swift, for example specializations for `std::shared_ptr`. In Nitro, I generate this into a file called [`*-Swift-Cxx-Bridge.hpp`](https://github.com/mrousavy/nitro/blob/main/packages/react-native-nitro-test/nitrogen/generated/ios/NitroTest-Swift-Cxx-Bridge.hpp).
- `First.swift`: The Swift file that defines Swift types (here, a class called `First`). This Swift class is exposed to C++, and also uses types from C++ (here, [`firstcpp.SharedPtrToFirst`](https://github.com/mrousavy/SwiftCxxCrossModuleImports/blob/35d02cdbca0065843d56ebe72b9bdd622f2543d5/FirstPod/CppTypesExposedToSwift.hpp#L7)).
- `First.hpp`/`First.cpp`: The C++ file that uses the Swift types in it's implementation (`First.cpp` via the imported `FirstPod-Swift.h` header), as well as in it's public API surface (`First.hpp`, via a forward declaration to not worry about _publicly_ importing `FirstPod-Swift.h` from outside of this module)

..same for `SecondPod`.

This works all fine when you have one module, but as soon as one module depends on another module (here, `FirstPod` depends on `SecondPod`) it will break the Swift compiler because of the types that will be generated in `*-Swift.h`.
You can try to work around the issue but it will always be one of those two problems;
- A) The autogenerated `FirstPod-Swift.h` header tries to use types that are not imported (like `SecondPod::Second`) - which is correct - `SecondPod-Swift.h` **should** not be imported outside of it's module as that is an implementation detail.
    ![](https://github.com/user-attachments/assets/a34a9926-1e94-4691-b2be-0d48f0f624e2)
- B) If you import `SecondPod-Swift.h` before you import `FirstPod-Swift.h`, you might solve issue A), but this will introduce two new issues;
  1. It will require frameworks (`use_frameworks!`) to be enabled, which is a no-go in some app setups.
  2. C++ types defined in `SecondPod`'s C++ code and then used in `SecondPod`'s Swift code (e.g. `using SomeType = std::shared_ptr<int>`), will cause redefinition errors if the same type is also defined and used in `FirstPod`, because the `*-Swift.h` headers generate code like `swift::isUsableFromGenericContext<SomeType> = true`. **So I think it is overall a bad idea to include other `*-Swift.h` headers other than the module's own one.**


## Solution

I created a discussion for this [here (`forums.swift.org`)](https://forums.swift.org/t/feature-print-external-types-in-swift-h-if-they-are-part-of-the-public-api/84208).

I think the solution is to just create the bridging part for `SecondPod::Second` inside `FirstPod-Swift.h`, instead of just relying on consumers that you will provide the definition for it.

For ABI safety, we could also introduce an autogenerated `*-Swift.cpp` file that contains the actual definition, while the `*-Swift.h` header just keeps the declaration - that way you just link against it and when the implementation (vTable/layout) changes, your part doesn't have to be recompiled.

I found this commit in the Swift compiler repo to be relevant: https://github.com/swiftlang/swift/commit/4fda7f4a9adb39ee57cf58393fad140cd7b510bb#diff-c74517ee05bd5ca55a093b3a6b8433967fdff6e6b99ecb3acccd73dc12b30fec -

## Generated code

### `FirstPod-Swift.h`

```cpp
class SWIFT_SYMBOL("s:8FirstPod0A0C") First : public swift::_impl::RefCountedClass {
public:
  using RefCountedClass::RefCountedClass;
  using RefCountedClass::operator=;
  static SWIFT_INLINE_THUNK First init() SWIFT_SYMBOL("s:8FirstPod0A0CACycfc");
  SWIFT_INLINE_THUNK void sayHello() SWIFT_SYMBOL("s:8FirstPod0A0C8sayHelloyyF");
  SWIFT_INLINE_THUNK std::__1::shared_ptr<firstcpp::FirstCpp> createCppPartNull() SWIFT_SYMBOL("s:8FirstPod0A0C17createCppPartNullSo3stdO3__1O0036shared_ptrfirstcppFirstCpp_gIADjHkpcVyF");
  SWIFT_INLINE_THUNK SecondPod::Second createSecond() SWIFT_SYMBOL("s:8FirstPod0A0C12createSecond0dB00D0CyF");
protected:
  SWIFT_INLINE_THUNK First(void * _Nonnull ptr) noexcept : RefCountedClass(ptr) {}
private:
  friend class _impl::_impl_First;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wc++17-extensions"
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-identifier"
  typedef char $s8FirstPod0A0CD;
  static inline constexpr $s8FirstPod0A0CD __swift_mangled_name = 0;
#pragma clang diagnostic pop
#pragma clang diagnostic pop
};
```

As you can see, `SecondPod::Second createSecond()` is generated - but `SecondPod::Second` is not defined.


### `SecondPod-Swift.h`

```cpp
class SWIFT_SYMBOL("s:9SecondPod0A0C") Second : public swift::_impl::RefCountedClass {
public:
  using RefCountedClass::RefCountedClass;
  using RefCountedClass::operator=;
  static SWIFT_INLINE_THUNK Second init() SWIFT_SYMBOL("s:9SecondPod0A0CACycfc");
  SWIFT_INLINE_THUNK void sayHello() SWIFT_SYMBOL("s:9SecondPod0A0C8sayHelloyyF");
  SWIFT_INLINE_THUNK std::__1::shared_ptr<secondcpp::SecondCpp> createCppPartNull() SWIFT_SYMBOL("s:9SecondPod0A0C17createCppPartNullSo3stdO3__1O0038shared_ptrsecondcppSecondCpp_keBCkzlvcVyF");
protected:
  SWIFT_INLINE_THUNK Second(void * _Nonnull ptr) noexcept : RefCountedClass(ptr) {}
private:
  friend class _impl::_impl_Second;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wc++17-extensions"
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-identifier"
  typedef char $s9SecondPod0A0CD;
  static inline constexpr $s9SecondPod0A0CD __swift_mangled_name = 0;
#pragma clang diagnostic pop
#pragma clang diagnostic pop
};
```

This is the part we could theoretically also just generate in `FirstPod-Swift.h`. _I think_.

## Experiment with `void*`

I also experimented with erasing the exposed Swift types in C++ completely by just passing the Swift instance as a `void*` - and then for every call I just call a static Swift method from C++, and downcast the `void*` to the Swift class+protocol inside Swift.
This generates much simpler C++ code in the `*-Swift.h` interop header, but effectively moves the downcast to Swift.
This is an example of a Swift implementation:
```swift
@inline(__always)
public static func getBoolValue(this: UnsafeRawPointer) -> Bool {
  let __instance = Unmanaged<HybridTestObjectSwiftKotlinSpec_base>.fromOpaque(this).takeUnretainedValue() as! HybridTestObjectSwiftKotlinSpec
  let __value = __instance.boolValue
  return __value
}
```
Due to the `as! ...` cast, it actually does two casts - once from `void*` to `HybridTestObjectSwiftKotlinSpec_base`, and then again for the `HybridTestObjectSwiftKotlinSpec` protocol via `as!`.
Previously in C++ we only had a `void*` cast to the concrete instance. So this is twice as much work.

And it shows;
- Before (main): 9.88ms
- After (`void*`): 15.85ms

..so this is not really a solution. It's also way less safe.
